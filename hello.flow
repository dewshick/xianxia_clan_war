import material/material_graphics;
import material/material_manager;
import material/material_dialog;



BCircle(r : double, coords : Point);
Entity(color : int, bounds : BCircle, moving : bool);

WorldState(entities : [Entity]);

// main() {
// 	println("Hello console!!!");
// 	coords = make(Pair(0., 0.));
// 	mrender(makeMaterialManager([]), false, MGroup([
// 		MCircle(10., [Fill(grey)]),
// 		MSelect(coords, unpairC(\x,y -> {
// 			MOffset(x, y, MCircle(10., [Fill(grey)]));
// 		}))
// 	]));

// 	updateLoop(\ -> next(coords, unpair(getValue(coords), \x, y -> Pair(x + 0.2, y + 0.2))));
// }

main() {

	w = WorldState(map(enumFromTo(1, 300), \__ -> {
		Entity(yellow, BCircle(5.0, Point(random() * 500.0, random() * 500.0)), true)
	}));
	renderWorld(w)
}

updateLoop(i : int, update : (int) -> void) -> void {
	timer(20, \ -> {
		update(i);
		updateLoop(i+1, update);
	});
}

renderWorld(world : WorldState) -> void {
	directions = map(world.entities, \__ -> Point(random() * 0.1, random() * 0.1));
	eCoords = map(world.entities, \e -> make(e.bounds.coords));
	mrender(makeMaterialManager([]), false, MGroup(zipWith(world.entities, eCoords, \entity, dirM -> {
		b = entity.bounds;
		coords = b.coords;
		MSelect(dirM, \dir -> MOffset(dir.x - b.r, dir.y - b.r, MCircle(b.r, [Fill(entity.color)])))
	})));
	updateLoop(0, \n -> {
		iteri(eCoords, \i, c -> {
			next(c, Point(
				getValue(c).x + i2d(n) * directions[i].x, 
				getValue(c).y + i2d(n) * directions[i].y
			))
		});
	});
}