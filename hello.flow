import material/material_graphics;
import material/material_manager;
import material/material_dialog;


GameObjectSchema(
	name : string,
	distToObj : double,
	radius : double,
	color : int,
	speed : double,
	// genus : Genus,
	// size : Size,
	// food : Genus
	// maxLifetime : int //use UInt64 later
);

// Genus ::= Plant, Animal;
// 	Plant(); Animal(); Nothing();

// Size ::= Big, Small;
// 	Big(); Small();

TREE = GameObjectSchema("Tree", 15.0, 8.0, svgName2color("brown", black), 0.0);
WANDERER = GameObjectSchema("Wanderer", 2.0, 4.0, black, 0.33);
PLAYER = GameObjectSchema("Player", 2.0, 4.0, svgName2color("violet", black), 0.33);
HARE  = GameObjectSchema("Hare", 2.0, 3.0, white, 0.9);
GRASS = GameObjectSchema("Grass", 0.0, 2.0, green, 0.0);
WOLF = GameObjectSchema("Wolf", 10.0, 6.0, red, 0.6);

BCircle(radius : double, coords : Point);

GameObject(
	schema : GameObjectSchema,
	bounds : DynamicBehaviour<BCircle>,
);

mkGameObject(schema : GameObjectSchema, coords : Point) -> GameObject {
	GameObject(schema, make(BCircle(schema.radius, coords)))
}

WorldState(entities : [GameObject]);

generateGameObject(state : WorldState, size : Point, schema : GameObjectSchema, attempts : int) -> Maybe<GameObject> {
	coords = Point(random() * size.x, random() * size.y);
	if (attempts == 0) {
		None()
	} else if (!exists(state.entities, \e -> {
		bounds = getValue(e.bounds);
		distance(bounds.coords, coords) < bounds.radius + schema.radius + schema.distToObj
	})) {
		Some(mkGameObject(schema, coords))
	} else {
		generateGameObject(state, size, schema, attempts-1)
	}
}

distance(a : Point, b : Point) -> double {
	sqrt(dpow(a.x - b.x, 2.0) + dpow(a.y - b.y, 2.0))
}

generateWorld(size : Point) -> WorldState {
	fold([
		Pair(TREE, 400), 
		Pair(WANDERER, 30), 
		Pair(PLAYER, 1), 
		Pair(HARE, 50), 
		Pair(WOLF, 10),
		Pair(GRASS, 10000), 
	], WorldState([]), \world, schemaCount -> {
		foldUntil(enumFromTo(1, schemaCount.second), world, \w, __ -> {
			eitherMap(
				generateGameObject(w, size, schemaCount.first, 10), 
				\obj -> Pair(true, WorldState(arrayPush(w.entities, obj))), 
				Pair(false, w)
			)
		})
	});
}

worldSize = Point(2048.0, 2048.0);

main() {
	renderWorld(generateWorld(worldSize))
}

updateLoop(i : int, update : (int) -> void) -> void {
	timer(20, \ -> {
		update(i);
		updateLoop(i + 1, update);
	});
}

renderWorld(world : WorldState) -> void {
	eCoords = map(world.entities, \e -> make(getValue(e.bounds).coords));
	mrender(makeMaterialManager([]), false, MGroup(concat(
		[TRectangle([Fill(svgName2color("greenyellow", black))], TFixed(worldSize.x, worldSize.y))], 
		zipWith(world.entities, eCoords, \entity, dirM -> {
			b = getValue(entity.bounds);
			coords = b.coords;
			MSelect(dirM, \dir -> MOffset(dir.x - b.radius, dir.y - b.radius, MCircle(b.radius, [Fill(entity.schema.color)])))
		})
	)));
	println("make it void for now");
}