import game_types;
import grid_index;
import object_storage;

export {
	WorldState(size : Point, objectIndex : ObjectIndex);
	initWorldState(size : Point) -> WorldState;
	addObjectToIndex(idxObjs : ObjectIndex, obj : GameObject) -> ObjectIndex;
	removeObjectFromIndex(idxObjs : ObjectIndex, id : int) -> ObjectIndex;
	mapObjectIndex(idxObjs : ObjectIndex, fn : (GameObject) -> GameObject) -> ObjectIndex;
	getObjects(idxObjs : ObjectIndex) -> [GameObject];
	getObjectsByLayers(idxObjs : ObjectIndex, layers : [int]) -> [GameObject];
}

initWorldState(size : Point) -> WorldState {
	WorldState(size, ObjectIndex(initObjectStorage(), initObjectsByLayer, ref initGridIndex(size)))
}

ObjectIndex(
	objects : ObjectStorage,
	objectsByLayer : [[int]],
	grid : ref GridIndex
);

addObjectToIndex(idxObjs : ObjectIndex, obj : GameObject) -> ObjectIndex {
	subscriber = \objId -> subscribeToUpd(obj.bounds, \old, new -> {
		idxObjs.grid := addObjectToGrid(objId, new, removeObjectFromGrid(objId, old, ^(idxObjs.grid)));
	});

	unpair(addObjectToStorage(obj, idxObjs.objects, subscriber), \objId, newObjects -> {
		objectsByLayerUpd = mapi(idxObjs.objectsByLayer, \i, objects -> {
			if (contains(obj.schema.layers, i)) arrayPush(objects, objId) else objects
		});
		ObjectIndex(newObjects, objectsByLayerUpd, idxObjs.grid)		
	});
}

subscribeToUpd(val : Behaviour<?>, fn : (?, ?) -> void) -> () -> void {
	oldVal = ref getValue(val);
	subscribe(val, \newVal -> {
		fn(^oldVal, newVal);
		oldVal := newVal;
	})
}

removeObjectFromIndex(idxObjs : ObjectIndex, id : int) -> ObjectIndex {
	unpair(removeObjectFromStorage(id, idxObjs.objects), \oldObj, objects -> {
		objectsByLayerUpd = mapi(idxObjs.objectsByLayer, \i, layerObjs -> {
			if (contains(oldObj.schema.layers, i)) removeAll(layerObjs, id) else layerObjs
		});
		idxObjs.grid := removeObjectFromGrid(id, getValue(oldObj.bounds), ^(idxObjs.grid));
		ObjectIndex(objects, objectsByLayerUpd, idxObjs.grid)
	})
}

mapObjectIndex(idxObjs : ObjectIndex, fn : (GameObject) -> GameObject) -> ObjectIndex {
	ObjectIndex(idxObjs with objects = ObjectStorage(idxObjs.objects with objects=mapTree(idxObjs.objects.objects, \objDisp -> {
		obj = objDisp.value;
		newObj = Disposable(fn(obj), objDisp.dispose);
		if (newObj.value.schema == obj.schema) {
			newObj
		} else {
			fail0("we assumed schema to be kept. now it changed from " + obj.schema.name + " to " + newObj.value.schema.name)
		}
	})))
}

getObjects(idxObjs : ObjectIndex) -> [GameObject] {
	map(getTreeValues(idxObjs.objects.objects), \obj -> obj.value)
}

getObjectsByLayers(idxObjs : ObjectIndex, layers : [int]) -> [GameObject] {
	idxSet = fold(layers, [], \set, layer -> concat(set, idxObjs.objectsByLayer[layer]));
	map(idxSet, \i -> eitherFn(lookupTree(idxObjs.objects.objects, i), \obj -> obj.value, \ -> fail0("in state, missing object " + i2s(i))));
}