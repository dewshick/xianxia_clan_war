import math/geometry;
import game_types;
import ds/arrayutils;

export {
	collidesWith(obj : GameObject, obj2 : GameObject, dist : double) -> bool;
	moveTowards(moved : GameObject, towards : GameObject) -> GameObject;
}

collidesWith(obj : GameObject, obj2 : GameObject, dist : double) -> bool {
	bounds = getValue(obj.bounds);
	bounds2 = getValue(obj2.bounds);

	distance(bounds.coords, bounds2.coords) < bounds.radius + bounds2.radius + dist &&
	intersection(obj.schema.collisionPlane, obj2.schema.collisionPlane) != []
}

moveTowards(moved : GameObject, towards : GameObject) -> GameObject {
	b = getValue(moved.bounds);
	direction = minusPoint(getValue(towards.bounds).coords, b.coords);
	movement = multPointScalar(vecNorm(direction), moved.schema.speed);
	next(moved.bounds, BCircle(b.radius, plusPoint(b.coords, movement)));
	moved
}

vecNorm(a : Point) -> Point {
	multPointScalar(a, 1.0 / vecLength(a))
}

distance(a : Point, b : Point) -> double {
	sqrt(dpow(a.x - b.x, 2.0) + dpow(a.y - b.y, 2.0))
}

vecLength(a : Point) -> double {
	distance(Point(0.0, 0.0), a)
}

multPointScalar(a : Point, n : double) -> Point {
	Point(a.x * n, a.y * n)
}

minusPoint(a : Point, b : Point) -> Point {
	Point(a.x - b.x, a.y - b.y)
}

plusPoint(a : Point, b : Point) -> Point {
	Point(a.x + b.x, a.y + b.y)
}



// fn avoid_collision<'a, T>(bounds : &CircleBounds, target : &Point, obstacles : &mut T) -> Direction
// where T : Iterator<Item=&'a CircleBounds> {
// 	let active_obs = obstacles.filter(|obs| obs.coords.dist(&bounds.coords) < obs.r + bounds.r &&
// 		(*target - bounds.coords).mults(&(obs.coords - bounds.coords)) > -0.1
// 	);

// 	let (avoid, count) = active_obs.fold((Direction::init(), 0), |(dir, count), obs| {
// 		(dir + (obs.coords - bounds.coords).norm().multf(bounds.r + obs.r - bounds.coords.dist(&obs.coords)), count + 1)
// 	});

// 	(avoid.norm().ort() - avoid).multf(1.0/ count.max(1) as Dist)
// }
