import material/material_graphics;
import material/material_manager;
import material/material_dialog;


GameObjectSchema(
	name : string,
	distToObj : double,
	radius : double,
	color : int,
	speed : double,
	collisionPlane : [int], // units with common planes avoid collisions with each other
	initGoals : [Goal]
);

Goal ::= Wander, Hunt, Reproduce, Avoid, MoveTowards;
	Wander();
	Hunt(schema : string);
	Reproduce();
	Avoid(schema : string);
	MoveTowards(coords : Point);

// TODO: maybe static checks for references in Avoid/Hunt? or constants?
// we cant have mutually recursive values, referring to each other unfortunately
TREE = GameObjectSchema("Tree", 15.0, 8.0, svgName2color("brown", black), 0.0, [0, 2], [Reproduce()]);
WANDERER = GameObjectSchema("Wanderer", 2.0, 4.0, black, 0.33, [2], [Wander()]);
PLAYER = GameObjectSchema("Player", 2.0, 4.0, svgName2color("violet", black), 0.33, [2], []);
HARE  = GameObjectSchema("Hare", 2.0, 3.0, white, 0.9, [2], [Avoid("Wolf"), Hunt("Grass")]);
WOLF = GameObjectSchema("Wolf", 10.0, 6.0, svgName2color("lightblue", black), 0.6, [2], [Hunt("Hare")]);
GRASS = GameObjectSchema("Grass", 0.0, 2.0, green, 0.0, [0], [Reproduce()]);

BCircle(radius : double, coords : Point);

GameObject(
	schema : GameObjectSchema,
	bounds : DynamicBehaviour<BCircle>,
	goals : [Goal]
);

mkGameObject(schema : GameObjectSchema, coords : Point) -> GameObject {
	GameObject(schema, make(BCircle(schema.radius, coords)), schema.initGoals)
}

WorldState(size : Point, gameObjects : [GameObject]);

generateGameObject(world : WorldState, schema : GameObjectSchema, attempts : int) -> Maybe<GameObject> {
	newObj = mkGameObject(schema, Point(random() * world.size.x, random() * world.size.y));
	if (attempts == 0) {
		None()
	} else if (!exists(world.gameObjects, \obj -> collidesWith(newObj, obj, schema.distToObj))) {
		Some(newObj)
	} else {
		generateGameObject(world, schema, attempts-1)
	}
}

collidesWith(obj : GameObject, obj2 : GameObject, dist : double) -> bool {
	bounds = getValue(obj.bounds);
	bounds2 = getValue(obj2.bounds);

	distance(bounds.coords, bounds2.coords) < bounds.radius + bounds2.radius + dist &&
	intersection(obj.schema.collisionPlane, obj2.schema.collisionPlane) != []
}

distance(a : Point, b : Point) -> double {
	sqrt(dpow(a.x - b.x, 2.0) + dpow(a.y - b.y, 2.0))
}

vecLength(a : Point) -> double {
	distance(Point(0.0, 0.0), a)
}

multPointScalar(a : Point, n : double) -> Point {
	Point(a.x * n, a.y * n)
}

minusPoint(a : Point, b : Point) -> Point {
	Point(a.x - b.x, a.y - b.y)
}

plusPoint(a : Point, b : Point) -> Point {
	Point(a.x + b.x, a.y + b.y)
}

generateWorld(size : Point) -> WorldState {
	sizeMult = \i -> ceil(i2d(i) * size.x * size.y / (defaultSize.x * defaultSize.y));
	fold([
		Pair(TREE, sizeMult(190)), 
		Pair(GRASS, sizeMult(7000)), 
		Pair(PLAYER, 1), 
		Pair(HARE, sizeMult(50)), 
		Pair(WOLF, sizeMult(10)),
		Pair(WANDERER, sizeMult(30)), 
	], WorldState(size, []), \world, schemaCount -> unpair(schemaCount, \schema, count -> {
		foldUntil(enumFromTo(1, count), world, \w, i -> {
			result = eitherMap(
				generateGameObject(w, schema, 10), 
				\obj -> Pair(true, WorldState(w.size, arrayPush(w.gameObjects, obj))), 
				Pair(false, w)
			);
			if (!result.first) { 	println("Fail: " + schema.name + " on " + i2s(i) + "of " + i2s(count)); }
			result
		})
	}));
}

defaultSize = Point(1024.0, 600.0);

main() {
	world = generateWorld(Point(200.0, 200.0));
	renderWorld(world);
	updateWorldLoop(world);
}

// todo: update world via fold with each updated gameObj
updateWorld(world : WorldState) -> WorldState {
	WorldState(world.size, map(world.gameObjects, \obj -> updGameObject(world, obj)))
}

updGameObject(world : WorldState, obj : GameObject) -> GameObject {
	either(findmap(obj.goals, \g -> switch (g) {
		Wander() : maybeMap(generateGameObject(world, obj.schema, 10), \newDest -> {
			updGoals : [Goal] = concat([MoveTowards(getValue(newDest.bounds).coords)], obj.goals);
			updGameObject(world, GameObject(obj with goals=updGoals));
		});
		Hunt(schema) : None(); //TODO
		Reproduce() : None(); //TODO
		Avoid(schema) : None(); //TODO
		MoveTowards(coords) : {
			b = getValue(obj.bounds);
			if (distance(coords, b.coords) < b.radius + 1.0) {
				Some(GameObject(obj with goals=removeFirst(obj.goals, g)))
			} else {
				direction = minusPoint(coords, b.coords);
				movement = multPointScalar(direction, obj.schema.speed / vecLength(direction));
				next(obj.bounds, BCircle(b.radius, plusPoint(b.coords, movement)));
				Some(obj);
			}
		};
	}), obj);
}

// fn avoid_collision<'a, T>(bounds : &CircleBounds, target : &Point, obstacles : &mut T) -> Direction
// where T : Iterator<Item=&'a CircleBounds> {
// 	let active_obs = obstacles.filter(|obs| obs.coords.dist(&bounds.coords) < obs.r + bounds.r &&
// 		(*target - bounds.coords).mults(&(obs.coords - bounds.coords)) > -0.1
// 	);

// 	let (avoid, count) = active_obs.fold((Direction::init(), 0), |(dir, count), obs| {
// 		(dir + (obs.coords - bounds.coords).norm().multf(bounds.r + obs.r - bounds.coords.dist(&obs.coords)), count + 1)
// 	});

// 	(avoid.norm().ort() - avoid).multf(1.0/ count.max(1) as Dist)
// }

updateWorldLoop(world : WorldState) -> void {
	timer(20, \ -> {
		updW = WorldState(world.size, map(world.gameObjects, \obj -> updGameObject(world, obj)));
		updateWorldLoop(updW);
	});
}

renderWorld(world : WorldState) -> () -> void {
	mrender(makeMaterialManager([]), false, MGroup(concat(
		[TRectangle([Fill(svgName2color("greenyellow", black))], TFixed(world.size.x, world.size.y))], 
		map(world.gameObjects, \gameObj -> {
			MSelect(gameObj.bounds, \bounds -> {
				MOffset(bounds.coords.x - bounds.radius, bounds.coords.y - bounds.radius, 
					MCircle(bounds.radius, [Fill(gameObj.schema.color)]))
			})
		})
	)));
}