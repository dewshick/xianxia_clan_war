import material/material_graphics;
import material/material_manager;
import material/material_dialog;
import collisions;

generateGameObject(world : WorldState, schema : GameObjectSchema, attempts : int) -> Maybe<GameObject> {
	newObj = mkGameObject(schema, Point(random() * world.size.x, random() * world.size.y));
	if (attempts == 0) {
		None()
	} else if (!exists(world.gameObjects, \obj -> collidesWith(newObj, obj, schema.distToObj))) {
		Some(newObj)
	} else {
		generateGameObject(world, schema, attempts-1)
	}
}

generateWorld(size : Point) -> WorldState {
	sizeMult = \i -> ceil(i2d(i) * size.x * size.y / (defaultSize.x * defaultSize.y));
	fold([
		Pair(TREE, sizeMult(190)), 
		Pair(GRASS, sizeMult(7000)), 
		Pair(PLAYER, 1), 
		Pair(HARE, sizeMult(50)), 
		Pair(WOLF, sizeMult(10)),
		Pair(WANDERER, sizeMult(30)), 
	], WorldState(size, []), \world, schemaCount -> unpair(schemaCount, \schema, count -> {
		foldUntil(enumFromTo(1, count), world, \w, i -> {
			result = eitherMap(
				generateGameObject(w, schema, 5), 
				\obj -> Pair(true, WorldState(w.size, arrayPush(w.gameObjects, obj))), 
				Pair(false, w)
			);
			if (!result.first) { 	println("Fail: " + schema.name + " on " + i2s(i) + "of " + i2s(count)); }
			result
		})
	}));
}

defaultSize = Point(1024.0, 600.0);

main() {
	world = generateWorld(defaultSize /*Point(200.0, 200.0)*/);
	renderWorld(world);
	updateWorldLoop(world);
}

// todo: update world via fold with each updated gameObj
updateWorld(world : WorldState) -> WorldState {
	WorldState(world.size, map(world.gameObjects, \obj -> updGameObject(world, obj)))
}

updGameObject(world : WorldState, obj : GameObject) -> GameObject {
	either(findmap(obj.goals, \g -> switch (g) {
		Wander() : maybeMap(generateGameObject(world, obj.schema, 10), \newDest -> {
			updGoals : [Goal] = concat([MoveTowards(newDest)], obj.goals);
			updGameObject(world, GameObject(obj with goals=updGoals));
		});
		Hunt(schema) : None(); //TODO
		Reproduce() : None(); //TODO
		Avoid(schema) : None(); //TODO
		MoveTowards(obj2) : {
			if (collidesWith(obj, obj2, 0.0)) {
				Some(GameObject(obj with goals=removeFirst(obj.goals, g)))
			} else {
				Some(moveTowards(obj, obj2))
			}
		};
	}), obj);
}

updateWorldLoop(world : WorldState) -> void {
	timer(33, \ -> {
		updW = WorldState(world.size, map(world.gameObjects, \obj -> updGameObject(world, obj)));
		updateWorldLoop(updW);
	});
}

renderWorld(world : WorldState) -> () -> void {
	mrender(makeMaterialManager([]), false, MGroup(concat(
		[TRectangle([Fill(svgName2color("greenyellow", black))], TFixed(world.size.x, world.size.y))], 
		map(world.gameObjects, \gameObj -> {
			MSelect(gameObj.bounds, \bounds -> {
				MOffset(bounds.coords.x - bounds.radius, bounds.coords.y - bounds.radius, 
					MCircle(bounds.radius, [Fill(gameObj.schema.color)]))
			})
		})
	)));
}