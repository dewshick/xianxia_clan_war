import material/material_graphics;
import material/material_manager;
import material/material_dialog;


GameObjectSchema(
	name : string,
	distToObj : double,
	radius : double,
	color : int,
	speed : double,
	goals : [Goal]
	// genus : Genus,
	// size : Size,
	// food : Genus
	// maxLifetime : int //use UInt64 later
);

// Genus ::= Plant, Animal;
// 	Plant(); Animal(); Nothing();

// Size ::= Big, Small;
// 	Big(); Small();

TREE = GameObjectSchema("Tree", 15.0, 8.0, svgName2color("brown", black), 0.0);
WANDERER = GameObjectSchema("Wanderer", 2.0, 4.0, black, 0.33);
PLAYER = GameObjectSchema("Player", 2.0, 4.0, svgName2color("violet", black), 0.33);
HARE  = GameObjectSchema("Hare", 2.0, 3.0, white, 0.9);
GRASS = GameObjectSchema("Grass", 0.0, 2.0, green, 0.0);
WOLF = GameObjectSchema("Wolf", 10.0, 6.0, svgName2color("lightblue", black), 0.6);

BCircle(radius : double, coords : Point);

GameObject(
	schema : GameObjectSchema,
	bounds : DynamicBehaviour<BCircle>,
);

mkGameObject(schema : GameObjectSchema, coords : Point) -> GameObject {
	GameObject(schema, make(BCircle(schema.radius, coords)))
}

WorldState(size : Point, entities : [GameObject]);

generateGameObject(world : WorldState, schema : GameObjectSchema, attempts : int) -> Maybe<GameObject> {
	coords = Point(random() * world.size.x, random() * world.size.y);
	if (attempts == 0) {
		None()
	} else if (!exists(world.entities, \e -> {
		bounds = getValue(e.bounds);
		distance(bounds.coords, coords) < bounds.radius + schema.radius + schema.distToObj
	})) {
		Some(mkGameObject(schema, coords))
	} else {
		generateGameObject(world, schema, attempts-1)
	}
}

distance(a : Point, b : Point) -> double {
	sqrt(dpow(a.x - b.x, 2.0) + dpow(a.y - b.y, 2.0))
}

generateWorld(size : Point) -> WorldState {
	sizeMult = \i -> ceil(i2d(i) * size.x * size.y / (defaultSize.x * defaultSize.y));
	fold([
		Pair(TREE, sizeMult(190)), 
		Pair(PLAYER, 1), 
		Pair(HARE, sizeMult(50)), 
		Pair(WOLF, sizeMult(10)),
		Pair(WANDERER, sizeMult(30)), 
		Pair(GRASS, sizeMult(5000)), 
	], WorldState(size, []), \world, schemaCount -> unpair(schemaCount, \schema, count -> {
		foldUntil(enumFromTo(1, count), world, \w, i -> {
			result = eitherMap(
				generateGameObject(w, schema, 10), 
				\obj -> Pair(true, WorldState(w.size, arrayPush(w.entities, obj))), 
				Pair(false, w)
			);
			if (!result.first) { 	println("Fail: " + schema.name + " on " + i2s(i) + "of " + i2s(count)); }
			result
		})
	}));
}

defaultSize = Point(1024.0, 600.0);

main() {
	renderWorld(generateWorld(Point(200.0, 200.0)))
}

updateLoop(i : int, update : (int) -> void) -> void {
	timer(20, \ -> {
		update(i);
		updateLoop(i + 1, update);
	});
}

renderWorld(world : WorldState) -> () -> void {
	eCoords = map(world.entities, \e -> make(getValue(e.bounds).coords));
	mrender(makeMaterialManager([]), false, MGroup(concat(
		[TRectangle([Fill(svgName2color("greenyellow", black))], TFixed(world.size.x, world.size.y))], 
		zipWith(world.entities, eCoords, \entity, dirM -> {
			b = getValue(entity.bounds);
			coords = b.coords;
			MSelect(dirM, \dir -> MOffset(dir.x - b.radius, dir.y - b.radius, MCircle(b.radius, [Fill(entity.schema.color)])))
		})
	)));
}