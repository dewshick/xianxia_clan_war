import behaviour;
import svg_colorname;
import math/geometry;
import ds/tree;
import basecolors;

export {

	WorldState(size : Point, objectIndex : ObjectIndex);

	initObjectIndex() -> ObjectIndex;
	addObjectToIndex(idxObjs : ObjectIndex, obj : GameObject) -> ObjectIndex;
	removeObjectFromIndex(idxObjs : ObjectIndex, id : int) -> ObjectIndex;
	mapObjectIndex(idxObjs : ObjectIndex, fn : (GameObject) -> GameObject) -> ObjectIndex;
	getObjects(idxObjs : ObjectIndex) -> [GameObject];
	getObjectsByLayers(idxObjs : ObjectIndex, layers : [int]) -> [GameObject];

	GameObject(
		schema : GameObjectSchema,
		bounds : DynamicBehaviour<BCircle>,
		goals : [Goal]
	);

	mkGameObject(schema : GameObjectSchema, coords : Point) -> GameObject;

	GameObjectSchema(
		name : string,
		distToObj : double,
		radius : double,
		color : int,
		speed : double,
		layers : [int], // units with common planes avoid collisions with each other
		initGoals : [Goal]
	);

	ground = 0;
	earth = 1;
	initObjectsByLayer = [[], []];

	// TODO: maybe static checks for references in Avoid/Hunt? or constants?
	// we cant have mutually recursive values, referring to each other unfortunately
	TREE = GameObjectSchema("Tree", 15.0, 8.0, svgName2color("brown", black), 0.0, [ground, earth], [Reproduce()]);
	WANDERER = GameObjectSchema("Wanderer", 2.0, 4.0, black, 0.33, [earth], [Wander()]);
	PLAYER = GameObjectSchema("Player", 2.0, 4.0, svgName2color("violet", black), 0.33, [earth], []);
	HARE  = GameObjectSchema("Hare", 2.0, 3.0, white, 0.9, [earth], [Avoid("Wolf"), Hunt("Grass")]);
	WOLF = GameObjectSchema("Wolf", 10.0, 6.0, svgName2color("lightblue", black), 0.6, [earth], [Hunt("Hare")]);
	GRASS = GameObjectSchema("Grass", 0.0, 2.0, green, 0.0, [ground], [Reproduce()]);


	BCircle(radius : double, coords : Point);

	Goal ::= Wander, Hunt, Reproduce, Avoid, MoveTowards;
		Wander();
		Hunt(schema : string);
		Reproduce();
		Avoid(schema : string);
		MoveTowards(obj : GameObject);
}


mkGameObject(schema : GameObjectSchema, coords : Point) -> GameObject {
	GameObject(schema, make(BCircle(schema.radius, coords)), schema.initGoals)
}

ObjectIndex(objects : Tree<int, GameObject>, objectsByLayer : [[int]], lastInsertId : int, freeIds : [int]);

initObjectIndex() -> ObjectIndex { ObjectIndex(makeTree(), initObjectsByLayer, -1, []) }

addObjectToIndex(idxObjs : ObjectIndex, obj : GameObject) -> ObjectIndex {
	indexParts = if (idxObjs.freeIds == []) {
		objId = idxObjs.lastInsertId + 1;
		Triple(objId, idxObjs.freeIds, objId)
	} else {
		Triple(idxObjs.freeIds[0], tail(idxObjs.freeIds), idxObjs.lastInsertId)
	}

	untriple(indexParts, \objId, freeIds, lastId -> {
		newObjects = setTree(idxObjs.objects, objId, obj);
		objectsByLayerUpd = mapi(idxObjs.objectsByLayer, \i, objects -> {
			if (contains(obj.schema.layers, i)) arrayPush(objects, objId) else objects
		});
		ObjectIndex(newObjects, objectsByLayerUpd, lastId, freeIds)
	})
}

removeObjectFromIndex(idxObjs : ObjectIndex, id : int) -> ObjectIndex {
	if (id > idxObjs.lastInsertId || id < 0) {
		println("wrong id: " + i2s(id) + " expected maximum id: " + i2s(idxObjs.lastInsertId));
		idxObjs;
	} else {
		oldObj = eitherFn(lookupTree(idxObjs.objects, id), idfn, \ -> fail0("missing index: " + i2s(id)));
		updObjects = removeFromTree(idxObjs.objects, id);
		objectsByLayerUpd = mapi(idxObjs.objectsByLayer, \i, objects -> {
			if (contains(oldObj.schema.layers, i)) removeAll(objects, id) else objects
		});
		ObjectIndex(updObjects, objectsByLayerUpd, idxObjs.lastInsertId, arrayPush(idxObjs.freeIds, id))
	}
}

mapObjectIndex(idxObjs : ObjectIndex, fn : (GameObject) -> GameObject) -> ObjectIndex {
	ObjectIndex(mapTree(idxObjs.objects, \obj -> {
		newObj = fn(obj);
		if (newObj.schema == obj.schema) {
			newObj
		} else {
			fail0("we assumed schema to be kept. now it changed from " + obj.schema.name + " to " + newObj.schema.name)
		}
	}), idxObjs.objectsByLayer, idxObjs.lastInsertId, idxObjs.freeIds)
}

getObjects(idxObjs : ObjectIndex) -> [GameObject] {
	getTreeValues(idxObjs.objects)
}

getObjectsByLayers(idxObjs : ObjectIndex, layers : [int]) -> [GameObject] {
	idxSet = fold(layers, [], \set, layer -> concat(set, idxObjs.objectsByLayer[layer]));
	map(idxSet, \i -> eitherFn(lookupTree(idxObjs.objects, i), idfn, \ -> fail0("in state, missing object " + i2s(i))));
}