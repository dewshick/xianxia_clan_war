import math/geometry;
import ds/tree;
import basecolors;
import transforms;
import grid_index;
import svg_colorname;

export {
	WorldState(size : Point, objectIndex : ObjectIndex);
	initWorldState(size : Point);
	addObjectToIndex(idxObjs : ObjectIndex, obj : GameObject) -> ObjectIndex;
	removeObjectFromIndex(idxObjs : ObjectIndex, id : int) -> ObjectIndex;
	mapObjectIndex(idxObjs : ObjectIndex, fn : (GameObject) -> GameObject) -> ObjectIndex;
	getObjects(idxObjs : ObjectIndex) -> [GameObject];
	getObjectsByLayers(idxObjs : ObjectIndex, layers : [int]) -> [GameObject];

	GameObject(
		schema : GameObjectSchema,
		bounds : DynamicBehaviour<BCircle>,
		goals : [Goal]
	);

	mkGameObject(schema : GameObjectSchema, coords : Point) -> GameObject;

	GameObjectSchema(
		name : string,
		distToObj : double,
		radius : double,
		color : int,
		speed : double,
		layers : [int], // units with common planes avoid collisions with each other
		initGoals : [Goal]
	);

	ObjectIndex(
		objects : Tree<int, Disposable<GameObject>>,
		objectsByLayer : [[int]],
		lastInsertId : int,
		freeIds : [int],
		grid : DynamicBehaviour<GridIndex>
	);

	ground = 0;
	earth = 1;
	initObjectsByLayer = [[], []];

	// TODO: maybe static checks for references in Avoid/Hunt? or constants?
	// we cant have mutually recursive values, referring to each other unfortunately
	TREE = GameObjectSchema("Tree", 15.0, 8.0, svgName2color("brown", black), 0.0, [ground, earth], [Reproduce()]);
	WANDERER = GameObjectSchema("Wanderer", 2.0, 4.0, black, 0.33, [earth], [Wander()]);
	PLAYER = GameObjectSchema("Player", 2.0, 4.0, svgName2color("violet", black), 0.33, [earth], []);
	HARE  = GameObjectSchema("Hare", 2.0, 3.0, white, 0.9, [earth], [Avoid("Wolf"), Hunt("Grass")]);
	WOLF = GameObjectSchema("Wolf", 10.0, 6.0, svgName2color("lightblue", black), 0.6, [earth], [Hunt("Hare")]);
	GRASS = GameObjectSchema("Grass", 0.0, 2.0, green, 0.0, [ground], [Reproduce()]);

	Goal ::= Wander, Hunt, Reproduce, Avoid, MoveTowards;
		Wander();
		Hunt(schema : string);
		Reproduce();
		Avoid(schema : string);
		MoveTowards(obj : GameObject);
}

mkGameObject(schema : GameObjectSchema, coords : Point) -> GameObject {
	GameObject(schema, make(BCircle(schema.radius, coords)), schema.initGoals)
}


initWorldState(size : Point) -> WorldState {
	WorldState(size, ObjectIndex(makeTree(), initObjectsByLayer, -1, [], make(initGridIndex(size))))
}

addObjectToIndex(idxObjs : ObjectIndex, obj : GameObject) -> ObjectIndex {
	indexParts = if (idxObjs.freeIds == []) {
		objId = idxObjs.lastInsertId + 1;
		Triple(objId, idxObjs.freeIds, objId)
	} else {
		Triple(idxObjs.freeIds[0], tail(idxObjs.freeIds), idxObjs.lastInsertId)
	}

	untriple(indexParts, \objId, freeIds, lastId -> {
		newObj = Disposable(obj, subscribeToUpd(obj.bounds, \old, new -> {
			next(idxObjs.grid, addObjectToGrid(objId, new, removeObjectFromGrid(objId, old, getValue(idxObjs.grid))));
		}));
		newObjects = setTree(idxObjs.objects, objId, newObj);
		objectsByLayerUpd = mapi(idxObjs.objectsByLayer, \i, objects -> {
			if (contains(obj.schema.layers, i)) arrayPush(objects, objId) else objects
		});
		ObjectIndex(newObjects, objectsByLayerUpd, lastId, freeIds, idxObjs.grid)
	})
}

subscribeToUpd(val : Behaviour<?>, fn : (?, ?) -> void) -> () -> void {
	oldVal = ref getValue(val);
	subscribe(val, \newVal -> {
		fn(^oldVal, newVal);
		oldVal := newVal;	
	})
}

removeObjectFromIndex(idxObjs : ObjectIndex, id : int) -> ObjectIndex {
	if (id > idxObjs.lastInsertId || id < 0) {
		println("wrong id: " + i2s(id) + " expected maximum id: " + i2s(idxObjs.lastInsertId));
		idxObjs;
	} else {
		oldObj = eitherFn(lookupTree(idxObjs.objects, id), idfn, \ -> fail0("missing index: " + i2s(id))).value;

		updObjects = removeFromTree(idxObjs.objects, id);
		objectsByLayerUpd = mapi(idxObjs.objectsByLayer, \i, objects -> {
			if (contains(oldObj.schema.layers, i)) removeAll(objects, id) else objects
		});
		next(idxObjs.grid, removeObjectFromGrid(id, getValue(oldObj.bounds), getValue(idxObjs.grid)));
		ObjectIndex(updObjects, objectsByLayerUpd, idxObjs.lastInsertId, arrayPush(idxObjs.freeIds, id), idxObjs.grid)
	}
}

mapObjectIndex(idxObjs : ObjectIndex, fn : (GameObject) -> GameObject) -> ObjectIndex {
	ObjectIndex(mapTree(idxObjs.objects, \objDisp -> {
		obj = objDisp.value;
		newObj = Disposable(fn(obj), objDisp.dispose);
		if (newObj.value.schema == obj.schema) {
			newObj
		} else {
			fail0("we assumed schema to be kept. now it changed from " + obj.schema.name + " to " + newObj.value.schema.name)
		}
	}), idxObjs.objectsByLayer, idxObjs.lastInsertId, idxObjs.freeIds, idxObjs.grid)
}

getObjects(idxObjs : ObjectIndex) -> [GameObject] {
	map(getTreeValues(idxObjs.objects), \obj -> obj.value)
}

getObjectsByLayers(idxObjs : ObjectIndex, layers : [int]) -> [GameObject] {
	idxSet = fold(layers, [], \set, layer -> concat(set, idxObjs.objectsByLayer[layer]));
	map(idxSet, \i -> eitherFn(lookupTree(idxObjs.objects, i), \obj -> obj.value, \ -> fail0("in state, missing object " + i2s(i))));
}