import ds/tree;
import game_types;

export {
	initGridIndex(size : Point) -> GridIndex;
	addObjectToGrid(id : int, bounds : BCircle, grid : GridIndex) -> GridIndex;
	removeObjectFromGrid(id : int, bounds : BCircle, grid : GridIndex) -> GridIndex;
	GridIndex(data : Tree<IntPoint, [int]>);
}


IntPoint(x : int, y : int);

gridCellSize = Point(10.0, 10.0);

initGridIndex(size : Point) -> GridIndex {
	xCoords : [int] = enumFromTo(0, ceil(size.x / gridCellSize.x));
	yCoords : [int] = enumFromTo(0, ceil(size.y / gridCellSize.y));

	allCoords = mapConcat(xCoords, \x -> map(yCoords, \y -> IntPoint(x,y)));
	GridIndex(pairs2tree(map(allCoords, \coord -> Pair(coord, []))));
}

boundingCells(bounds : BCircle) -> [IntPoint] {
	xRange = enumFromTo(
		floor((bounds.coords.x - bounds.radius)/gridCellSize.x),
		ceil((bounds.coords.x - bounds.radius)/gridCellSize.x)
	);

	yRange = enumFromTo(
		floor((bounds.coords.y - bounds.radius)/gridCellSize.y),
		ceil((bounds.coords.y - bounds.radius)/gridCellSize.y)
	);
	mapConcat(xRange, \x -> map(yRange, \y -> IntPoint(x,y)))
}

addObjectToGrid(id : int, bounds : BCircle, grid : GridIndex) -> GridIndex {
	GridIndex(fold(boundingCells(bounds), grid.data, \tree, cell -> treePushToArrayValue(tree, cell, id)))
}

removeObjectFromGrid(id : int, bounds : BCircle, grid : GridIndex) -> GridIndex {
	GridIndex(fold(boundingCells(bounds), grid.data, \tree, cell -> treeRemoveFromArrayValue(tree, cell, id)))
}